{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Beamtime calibration suite This repository contains scripts ran during (or in-between) beamtimes to support calibrating LCLS detectors Some more general info can be found on the team's confluence page: https://confluence.slac.stanford.edu/display/LCLSDET/LCLS+Detector+Department+Home File organization: The following describes what and where things are: /calibrationSuite: The library code lives here, and the functions can be imported into other scripts as such: from calibrationSuite.basicSuiteScript import * from calibrationSuite.fitFunctions import * from calibrationSuite.Stats import * from calibrationSuite.cluster import * ... (documentation on the library functionality is still to come, but example usage is seen by scripts in the /suite_scripts folder) /suite_scripts : scripts that use the calibrationSuite library code ('high-level scripts') /standalone_scripts : scripts that do not use the calibrationSuite library code ('high-level scripts') /tests : tests files, can be ran with 'pytest .' from the root project directory (Currently only test for the fitFunctions library file is running, more tests are to be added) /data : example data-files used for running the scripts Important branches: development : contains the newest 'good' code, usually has new changes and bug fixes. main : stable code that's used during beamtimes. The code from each beamtime (including the changes made during) is tagged.","title":"Home"},{"location":"#beamtime-calibration-suite","text":"This repository contains scripts ran during (or in-between) beamtimes to support calibrating LCLS detectors Some more general info can be found on the team's confluence page: https://confluence.slac.stanford.edu/display/LCLSDET/LCLS+Detector+Department+Home","title":"Beamtime calibration suite"},{"location":"#file-organization","text":"The following describes what and where things are: /calibrationSuite: The library code lives here, and the functions can be imported into other scripts as such: from calibrationSuite.basicSuiteScript import * from calibrationSuite.fitFunctions import * from calibrationSuite.Stats import * from calibrationSuite.cluster import * ... (documentation on the library functionality is still to come, but example usage is seen by scripts in the /suite_scripts folder) /suite_scripts : scripts that use the calibrationSuite library code ('high-level scripts') /standalone_scripts : scripts that do not use the calibrationSuite library code ('high-level scripts') /tests : tests files, can be ran with 'pytest .' from the root project directory (Currently only test for the fitFunctions library file is running, more tests are to be added) /data : example data-files used for running the scripts","title":"File organization:"},{"location":"#important-branches","text":"development : contains the newest 'good' code, usually has new changes and bug fixes. main : stable code that's used during beamtimes. The code from each beamtime (including the changes made during) is tagged.","title":"Important branches:"},{"location":"commands/","text":"Git Commands for Common Tasks A) Getting the latest changes for use at a beamtime git fetch //if beamtime is across multiple days, use 1st day date git switch beamtime_<month>_<day>_<year> B) Getting the latest changes from the development branch git pull origin development C) Saving a new feature/script/bugfix/etc: make sure you have the latest changes from the remote: git pull origin development make a branch for your feature off of the development branch: git checkout -b <feature_branch_name> development modify and commit the code, which will probably involve usage of the following commands: git status git add <filename> git commit -m <commit-message> push your feature branch to remote git push origin <feature_branch_name> if want to merge your changes into the development branch (and keep them long-term) follow F) and make a pull-request from your feature-branch into development D) If pulling down someone else's branch (non main/development branch): get updated branch info from remote git fetch origin see list of remote branches (optional) git branch -r checkout their branch (use the branch name without the 'oriogin/' prefix) git checkout <other_person_branch_name> E) Switching between two branches: if the following command lists two branches: git branch you can switch between them with: git checkout <branch_want_to_switch_to> F) Making pull request (one branch has been pushed to the remote): go to: https://github.com/slaclab/beamtime-calibration-suite/pulls click green 'New pull request' button in upper right you will see two grey boxes containing branch names and an arrow pointing from one box to the other the \"compare: ...\" box is the branch that will get merged into the \"base: ...\" box's branch the base should be the branch named development once the grey boxes are set correctly, click the green 'Create pull request' button once branch is ready to merge, you can click the ''Merge pull request' button to merge the commit being ready means: potentially reviewed (if big change), passing any automated checks/tests, etc if github is not allowing the merge automatically, you will need to merge or rebase locally and manually handle the conflicts G) Check out tagged commit (old beamtime code is tagged): same syntax as checking-out a branch, but use tag name instead: git checkout <tag_name> //ex: 'git checkout v1.0.0'","title":"Useful Git Commands"},{"location":"commands/#git-commands-for-common-tasks","text":"","title":"Git Commands for Common Tasks"},{"location":"commands/#a-getting-the-latest-changes-for-use-at-a-beamtime","text":"git fetch //if beamtime is across multiple days, use 1st day date git switch beamtime_<month>_<day>_<year>","title":"A) Getting the latest changes for use at a beamtime"},{"location":"commands/#b-getting-the-latest-changes-from-the-development-branch","text":"git pull origin development","title":"B) Getting the latest changes from the development branch"},{"location":"commands/#c-saving-a-new-featurescriptbugfixetc","text":"make sure you have the latest changes from the remote: git pull origin development make a branch for your feature off of the development branch: git checkout -b <feature_branch_name> development modify and commit the code, which will probably involve usage of the following commands: git status git add <filename> git commit -m <commit-message> push your feature branch to remote git push origin <feature_branch_name> if want to merge your changes into the development branch (and keep them long-term) follow F) and make a pull-request from your feature-branch into development","title":"C) Saving a new feature/script/bugfix/etc:"},{"location":"commands/#d-if-pulling-down-someone-elses-branch-non-maindevelopment-branch","text":"get updated branch info from remote git fetch origin see list of remote branches (optional) git branch -r checkout their branch (use the branch name without the 'oriogin/' prefix) git checkout <other_person_branch_name>","title":"D) If pulling down someone else's branch (non main/development branch):"},{"location":"commands/#e-switching-between-two-branches","text":"if the following command lists two branches: git branch you can switch between them with: git checkout <branch_want_to_switch_to>","title":"E) Switching between two branches:"},{"location":"commands/#f-making-pull-request-one-branch-has-been-pushed-to-the-remote","text":"go to: https://github.com/slaclab/beamtime-calibration-suite/pulls click green 'New pull request' button in upper right you will see two grey boxes containing branch names and an arrow pointing from one box to the other the \"compare: ...\" box is the branch that will get merged into the \"base: ...\" box's branch the base should be the branch named development once the grey boxes are set correctly, click the green 'Create pull request' button once branch is ready to merge, you can click the ''Merge pull request' button to merge the commit being ready means: potentially reviewed (if big change), passing any automated checks/tests, etc if github is not allowing the merge automatically, you will need to merge or rebase locally and manually handle the conflicts","title":"F) Making pull request (one branch has been pushed to the remote):"},{"location":"commands/#g-check-out-tagged-commit-old-beamtime-code-is-tagged","text":"same syntax as checking-out a branch, but use tag name instead: git checkout <tag_name> //ex: 'git checkout v1.0.0'","title":"G) Check out tagged commit (old beamtime code is tagged):"},{"location":"environment/","text":"Setup Environment When running on S3DF, you will first need to setup your environment for python , libraries like psana , etc: source /sdf/group/lcls/ds/ana/sw/conda2/manage/bin/psconda.sh Then you can execute the following to setup some project-specific things (must be ran from beamtime-calibration-suite folder): source setup.sh (This must be ran in each new terminal session) This script simplifies setting up the terminal environment and should be all the environment setup most users will need to do This script does the following: * appends your cloned location of this library to your PYTHONPATH , so scripts in /suite_scripts and other locations on your machine can find the library code * sets the library's output-root to the shared /rix dir used for the current experiment git * sets the config file to the currently used rixSuiteConfig.py file The rest of the page has more detail on configuring the scripts. Specifying Output Root The output-root determines where the library will look for an output folder. For example, if the root is set to the default value /sdf/data/lcls/ds/rix/rixx1003721/results/scripts/ , the library will look for an output dir ../scan in the location /sdf/data/lcls/ds/rix/rixx1003721/results/scripts/../scan . The output-directory can be set using the -p <dir_name> cmdline arg. Setting the var to nothing ( export OUTPUT_ROOT= ) will have the library look for an output folder relative to the location of the current script being ran Point to Config File Specify which config file for the library to use by setting the SUITE_CONFIG environment variable: export SUITE_CONFIG=\"rixSuiteConfig.py\" (relative or full paths should work) You can also set the config-file using the '-cf' or '--configFile' cmd-line arguments (note: if set, the environment variable will always override this cmd-line option) If neither of the above are set, the suite will try to use a default file named suiteConfig.py If no config file can be found and read, the library will fail-out early","title":"Environment"},{"location":"environment/#setup-environment","text":"When running on S3DF, you will first need to setup your environment for python , libraries like psana , etc: source /sdf/group/lcls/ds/ana/sw/conda2/manage/bin/psconda.sh Then you can execute the following to setup some project-specific things (must be ran from beamtime-calibration-suite folder): source setup.sh (This must be ran in each new terminal session) This script simplifies setting up the terminal environment and should be all the environment setup most users will need to do This script does the following: * appends your cloned location of this library to your PYTHONPATH , so scripts in /suite_scripts and other locations on your machine can find the library code * sets the library's output-root to the shared /rix dir used for the current experiment git * sets the config file to the currently used rixSuiteConfig.py file The rest of the page has more detail on configuring the scripts.","title":"Setup Environment"},{"location":"environment/#specifying-output-root","text":"The output-root determines where the library will look for an output folder. For example, if the root is set to the default value /sdf/data/lcls/ds/rix/rixx1003721/results/scripts/ , the library will look for an output dir ../scan in the location /sdf/data/lcls/ds/rix/rixx1003721/results/scripts/../scan . The output-directory can be set using the -p <dir_name> cmdline arg. Setting the var to nothing ( export OUTPUT_ROOT= ) will have the library look for an output folder relative to the location of the current script being ran","title":"Specifying Output Root"},{"location":"environment/#point-to-config-file","text":"Specify which config file for the library to use by setting the SUITE_CONFIG environment variable: export SUITE_CONFIG=\"rixSuiteConfig.py\" (relative or full paths should work) You can also set the config-file using the '-cf' or '--configFile' cmd-line arguments (note: if set, the environment variable will always override this cmd-line option) If neither of the above are set, the suite will try to use a default file named suiteConfig.py If no config file can be found and read, the library will fail-out early","title":"Point to Config File"},{"location":"learning_git/","text":"Learning Git this project uses git as a version control system, along with the GitHub website for hosting the code and multiple other features if you want a good understanding of git, suggest to read the first 3 chapters of https://git-scm.com/book/en/v2 : * the following sections could be skipped: 1.5, 1.6, 2.6, 2.7, 3.5, 3.6 * the book is a recommended resource by the git community but many other tutorials exist, so feel free to use other 'intro to git/github' videos/websites short presentation that summaries the book's content can be found here presentation from SLAC that explains git, github, git workflow, etc can be found here git commands cheat-sheet can be found here (**link will start download of pdf cheat sheet) (if you plan on developing the library) read about GitHub's 'Pull Request' feature here for commit messages, we can try to follow the PyDM guidelines","title":"Learning Git"},{"location":"learning_git/#learning-git","text":"this project uses git as a version control system, along with the GitHub website for hosting the code and multiple other features if you want a good understanding of git, suggest to read the first 3 chapters of https://git-scm.com/book/en/v2 : * the following sections could be skipped: 1.5, 1.6, 2.6, 2.7, 3.5, 3.6 * the book is a recommended resource by the git community but many other tutorials exist, so feel free to use other 'intro to git/github' videos/websites short presentation that summaries the book's content can be found here presentation from SLAC that explains git, github, git workflow, etc can be found here git commands cheat-sheet can be found here (**link will start download of pdf cheat sheet) (if you plan on developing the library) read about GitHub's 'Pull Request' feature here for commit messages, we can try to follow the PyDM guidelines","title":"Learning Git"},{"location":"logging/","text":"Logging Logging calls are added to the library code, and also to some commonly used files in /suite_scripts to act as example Using the following method will append log messages to the log-file if it already exists, or create a new log-file if the file doesn't exist If you want a new log-file for each run of a high-level script, atm you will need to rename the log-file after each run so a new one will be generated To have your high-level script generate logs from the calibrationSuite library code, add the following at the top of the script: import os import calibrationSuite.loggingSetup as ls currFileName = os.path.basename(__file__) ls.setupScriptLogging(\"../logs\" + currFileName[:-3] + \".log\", logging.ERROR) Pass in logging.INFO instead to get alot more output on the state of the program, while also still logging the logging.ERROR messages You can pass any chosen log-file name to the setupScriptLogging function, but using the above will create and write to file named beamtime-calibration-suite/logs/\\<curr script name>.log To add more logging from the high-level script itself (to the same file specified to setupScriptLogging ), you can add the following to the top of the script: import logging logger = logging.getLogger(__name__) Then can add log statements throughout the script with: logger.error(\"Example error msg!\") # for logging when the program goes wrong logger.exception(\"Example exception msg!) # for logging error and also including stack-trace in log logger.info(\"Example info msg!\") # for logging useful info on the state of the program (Note: these must take a statement evaluating to a single string, if 'a', 'b', 'c' are strings you can't do 'logger.info(a,b,c)' but can do 'logger.info(a+b+c)'. And if 'a' is an int, must do 'logger.info(str(a)))","title":"Logging"},{"location":"logging/#logging","text":"Logging calls are added to the library code, and also to some commonly used files in /suite_scripts to act as example Using the following method will append log messages to the log-file if it already exists, or create a new log-file if the file doesn't exist If you want a new log-file for each run of a high-level script, atm you will need to rename the log-file after each run so a new one will be generated To have your high-level script generate logs from the calibrationSuite library code, add the following at the top of the script: import os import calibrationSuite.loggingSetup as ls currFileName = os.path.basename(__file__) ls.setupScriptLogging(\"../logs\" + currFileName[:-3] + \".log\", logging.ERROR) Pass in logging.INFO instead to get alot more output on the state of the program, while also still logging the logging.ERROR messages You can pass any chosen log-file name to the setupScriptLogging function, but using the above will create and write to file named beamtime-calibration-suite/logs/\\<curr script name>.log To add more logging from the high-level script itself (to the same file specified to setupScriptLogging ), you can add the following to the top of the script: import logging logger = logging.getLogger(__name__) Then can add log statements throughout the script with: logger.error(\"Example error msg!\") # for logging when the program goes wrong logger.exception(\"Example exception msg!) # for logging error and also including stack-trace in log logger.info(\"Example info msg!\") # for logging useful info on the state of the program (Note: these must take a statement evaluating to a single string, if 'a', 'b', 'c' are strings you can't do 'logger.info(a,b,c)' but can do 'logger.info(a+b+c)'. And if 'a' is an int, must do 'logger.info(str(a)))","title":"Logging"},{"location":"setup/","text":"Github and Git Setup These steps will get you setup for running and developing the calibration suite! The steps describe the setup for using the scripts on the SLAC Shared Scientific Data Facility (S3DF) A S3DF account is needed before following these steps, and info on how to get one is here The only other prerequisites should be a terminal that can run Unix commands (mac and linux have this by default), and basic knowledge of using the terminal! 1: Make a github.com account if you already have github account and want to use it, skip to step 2) else to make a new account following the steps here: https://github.com/join your username can be anything, some people like to use the <username>-slac convention (ex: nstelter-slac ) for the email you can use your @slac.stanford.edu address or any other address if you want (just make sure to use the same email in step 5) you will need a code from your email when creating the account 2: Register your github account with \u2018SLAC Lab\u2019 github group first join \u2018#comp-general\u2019 channel on Slack now when viewing this slack channel you should see \u2018Pinned\u2019 and next to it \u2018Workflows\u2019 at top of the page click \u2018Workflows\u2019 -> \u2018SLAC GitHub Access\u2019, and fill out the form with your info wait to receive an email asking you to join the \u2018SLAC Lab\u2019 group, and follow instructions in this email 3: Request write permissions for the repository after completing step 2) , your github account should now be a member of the 'SLAC Lab' github group now go to https://github.com/orgs/slaclab/teams/beamtime_calibration_suite_devs and click the 'Request to join' button towards the upper-right of the page this will grant you write access to the repository (used for development and sharing code-changes during beamtime) 4: Setup your terminal for next steps for the following steps 5) , 6) , 7) , 8) , make sure you terminal (linux or mac) is setup first with the following commands: (note: in the 1st command replace <slac-username> with your slac unix account-name) ssh -Yt <slac-username>@s3dflogin.slac.stanford.edu //now enter your info to login to s3df... source /sdf/group/lcls/ds/ana/sw/conda2/manage/bin/psconda.sh all commands entered in the following steps should be done so in this setup terminal (the terminal should now have an active ssh session into S3DF) 5: Config your local git settings Run the following terminal commands: git config --global user.name <github username> git config --global user.email <email used to setup github account> //run one of the following cmds, depending on your preferred editor //(the editor is used during some git operations) git config --global core.editor vim git config --global core.editor emacs 6: Setup SSH Keys for github on s3df first make sure you are logged into your github account in your web browser for the next two bullet-points, make sure you have selected the 'Linux' tab near the top of the page, not 'Mac'! Follow instructions under \u201cGenerating a new SSH key\u201d and \u201cAdding your SSH key to the ssh-agent\u201d: https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent#generating-a-new-ssh-key Follow instructions under \u201cAdding a new SSH key to your account\u201d: https://docs.github.com/en/authentication/connecting-to-github-with-ssh/adding-a-new-ssh-key-to-your-github-account#adding-a-new-ssh-key-to-your-account 7: Download the repo run the following terminal commands: cd ~ mkdir repos cd repos git clone git@github.com:slaclab/beamtime-calibration-suite.git //wait for download to finish... cd beamtime-calibration-suite git switch development ls //should see a bunch of folders! cd suite_scripts ls //now should see a bunch of python scripts! if an error occurs during these commands, SSH setup in step 6) may have had an issue and might need to be debugged 8: Run an example script run the following terminal commands: cd ~/repos/beamtime_calibtation_suite source /sdf/group/lcls/ds/ana/sw/conda2/manage/bin/psconda.sh source setup.sh mkdir setup_test_output cd suite_scripts //'OUTPUT_ROOT=' sets the OUTPUT_ROOT environment var to an empty value, //which causes the script to look relative to the current directory for the output folder OUTPUT_ROOT= python EventScanParallelSlice.py -r 457 -p ../setup_test_output //let the script run to completion... ls -lt ../setup_test_output //if ran correctly, should see these non-empty files: //EventScanParallel_c0_r349_n1.h5, eventNumbers_c0_r349_rixx1003721.npy, means_c0_r349_rixx1003721.npy","title":"Setup"},{"location":"setup/#github-and-git-setup","text":"These steps will get you setup for running and developing the calibration suite! The steps describe the setup for using the scripts on the SLAC Shared Scientific Data Facility (S3DF) A S3DF account is needed before following these steps, and info on how to get one is here The only other prerequisites should be a terminal that can run Unix commands (mac and linux have this by default), and basic knowledge of using the terminal!","title":"Github and Git Setup"},{"location":"setup/#1-make-a-githubcom-account","text":"if you already have github account and want to use it, skip to step 2) else to make a new account following the steps here: https://github.com/join your username can be anything, some people like to use the <username>-slac convention (ex: nstelter-slac ) for the email you can use your @slac.stanford.edu address or any other address if you want (just make sure to use the same email in step 5) you will need a code from your email when creating the account","title":"1: Make a github.com account"},{"location":"setup/#2-register-your-github-account-with-slac-lab-github-group","text":"first join \u2018#comp-general\u2019 channel on Slack now when viewing this slack channel you should see \u2018Pinned\u2019 and next to it \u2018Workflows\u2019 at top of the page click \u2018Workflows\u2019 -> \u2018SLAC GitHub Access\u2019, and fill out the form with your info wait to receive an email asking you to join the \u2018SLAC Lab\u2019 group, and follow instructions in this email","title":"2: Register your github account with \u2018SLAC Lab\u2019 github group"},{"location":"setup/#3-request-write-permissions-for-the-repository","text":"after completing step 2) , your github account should now be a member of the 'SLAC Lab' github group now go to https://github.com/orgs/slaclab/teams/beamtime_calibration_suite_devs and click the 'Request to join' button towards the upper-right of the page this will grant you write access to the repository (used for development and sharing code-changes during beamtime)","title":"3: Request write permissions for the repository"},{"location":"setup/#4-setup-your-terminal-for-next-steps","text":"for the following steps 5) , 6) , 7) , 8) , make sure you terminal (linux or mac) is setup first with the following commands: (note: in the 1st command replace <slac-username> with your slac unix account-name) ssh -Yt <slac-username>@s3dflogin.slac.stanford.edu //now enter your info to login to s3df... source /sdf/group/lcls/ds/ana/sw/conda2/manage/bin/psconda.sh all commands entered in the following steps should be done so in this setup terminal (the terminal should now have an active ssh session into S3DF)","title":"4: Setup your terminal for next steps"},{"location":"setup/#5-config-your-local-git-settings","text":"Run the following terminal commands: git config --global user.name <github username> git config --global user.email <email used to setup github account> //run one of the following cmds, depending on your preferred editor //(the editor is used during some git operations) git config --global core.editor vim git config --global core.editor emacs","title":"5: Config your local git settings"},{"location":"setup/#6-setup-ssh-keys-for-github-on-s3df","text":"first make sure you are logged into your github account in your web browser for the next two bullet-points, make sure you have selected the 'Linux' tab near the top of the page, not 'Mac'! Follow instructions under \u201cGenerating a new SSH key\u201d and \u201cAdding your SSH key to the ssh-agent\u201d: https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent#generating-a-new-ssh-key Follow instructions under \u201cAdding a new SSH key to your account\u201d: https://docs.github.com/en/authentication/connecting-to-github-with-ssh/adding-a-new-ssh-key-to-your-github-account#adding-a-new-ssh-key-to-your-account","title":"6: Setup SSH Keys for github on s3df"},{"location":"setup/#7-download-the-repo","text":"run the following terminal commands: cd ~ mkdir repos cd repos git clone git@github.com:slaclab/beamtime-calibration-suite.git //wait for download to finish... cd beamtime-calibration-suite git switch development ls //should see a bunch of folders! cd suite_scripts ls //now should see a bunch of python scripts! if an error occurs during these commands, SSH setup in step 6) may have had an issue and might need to be debugged","title":"7: Download the repo"},{"location":"setup/#8-run-an-example-script","text":"run the following terminal commands: cd ~/repos/beamtime_calibtation_suite source /sdf/group/lcls/ds/ana/sw/conda2/manage/bin/psconda.sh source setup.sh mkdir setup_test_output cd suite_scripts //'OUTPUT_ROOT=' sets the OUTPUT_ROOT environment var to an empty value, //which causes the script to look relative to the current directory for the output folder OUTPUT_ROOT= python EventScanParallelSlice.py -r 457 -p ../setup_test_output //let the script run to completion... ls -lt ../setup_test_output //if ran correctly, should see these non-empty files: //EventScanParallel_c0_r349_n1.h5, eventNumbers_c0_r349_rixx1003721.npy, means_c0_r349_rixx1003721.npy","title":"8: Run an example script"},{"location":"standalone_scripts/","text":"Standalone scripts: wip: add descriptions, how to run, etc cfg_utils.py dumpPVs.py * plotWave8.py compareConfigs.py MapCompEnOn.py roiCombinationExample.py DamageCounter.py MapCompEnOnThreshold.py seabornTest.py Debugging.py nonBasicScript.py simpler_epixhr.py dumbBandPlotter.py * OpenXav.py","title":"Standalone Scripts"},{"location":"standalone_scripts/#standalone-scripts","text":"wip: add descriptions, how to run, etc cfg_utils.py dumpPVs.py * plotWave8.py compareConfigs.py MapCompEnOn.py roiCombinationExample.py DamageCounter.py MapCompEnOnThreshold.py seabornTest.py Debugging.py nonBasicScript.py simpler_epixhr.py dumbBandPlotter.py * OpenXav.py","title":"Standalone scripts:"},{"location":"suite_scripts/","text":"Suite scripts: wip: add descriptions, how to run, etc AnalyzeH5.py runAnalyzeH5.py runInfo.py searchForNonSwitching.py SimpleClustersParallel.py SimpleClustersParallelSlice.py simplePhotonCounter.py TimeScan_jm.py roiFromSwitched.py analyze_npy.py batchModeXav.sh CalcNoiseAndMean.py DeltaTtest.py deprecatedLinearityPlotsParallel.py EventScanM.py EventScanParallel.py TimeScanParallel.py EventScanParallelSlice.py * findMinSwitchValue.py histogramFluxEtc.py LinearityPlotsParallelSlice.py TimeScanParallelSlice.py TimeScanParallel_bhavna.py PersistenceCheckParallel.py persistenceCheck.py TimeScanParallelXav.py roiFromThreshold.py * rixSuiteConfig.py","title":"Suite Scripts"},{"location":"suite_scripts/#suite-scripts","text":"wip: add descriptions, how to run, etc AnalyzeH5.py runAnalyzeH5.py runInfo.py searchForNonSwitching.py SimpleClustersParallel.py SimpleClustersParallelSlice.py simplePhotonCounter.py TimeScan_jm.py roiFromSwitched.py analyze_npy.py batchModeXav.sh CalcNoiseAndMean.py DeltaTtest.py deprecatedLinearityPlotsParallel.py EventScanM.py EventScanParallel.py TimeScanParallel.py EventScanParallelSlice.py * findMinSwitchValue.py histogramFluxEtc.py LinearityPlotsParallelSlice.py TimeScanParallelSlice.py TimeScanParallel_bhavna.py PersistenceCheckParallel.py persistenceCheck.py TimeScanParallelXav.py roiFromThreshold.py * rixSuiteConfig.py","title":"Suite scripts:"},{"location":"workflow/","text":"Git/GitHub Workflow we should try to generally follow the branching and pull-request workflow described in this SLAC presentation * in our case the two important branches will be main and development * in-between beamtimes, development is used for pushing work * right before beamtimes, development is merged into main * then a branch named beamtime \\ \\ is branched off main * this branch is used for sharing code fixes/changes (pushing-to and pulling-from) during beamtime * after beamtimes, we merge _beamtime \\ \\ back into _main and tag it branching workflow Before Beamtime: checkout development (or a earlier stable point of development ) manually run and check the output of script planned for use on the beamtime, as a final sanity check use a pull request to merge development into main to do this follow the instructions in section F) of the doc page Git Commands for Common Tasks main is safeguarded and will require a +1 from another developer make a branch for work during this specific beamtime git checkout -b main beamtime_<month>_<day>_<year> git push origin beamtime_<month>_<day>_<year> During Beamtime: at start of beamtime, everyone needs to download the branch for this beamtime: git fetch git switch beamtime_<month>_<day>_<year> If you need to make changes to the code, first make sure your files are up to date: git pull Now make your changes and upload them: git add -u git commit -m \"<description of changes made>\" git push origin beamtime_<month>_<day>_<year> If someone else made and upload changes, you can download them by doing: git pull After Beamtime: make sure all the changes that need to be saved are commited to beamtime \\ \\ _ use a pull request to merge beamtime_ \\ \\ into main add a tag for the beamtime //tag number is arbitrary at this point, just look at last tag and increment one of the values git tag v<tag number> -a //an example tag number would be 1.0.3 //this will open your editor to write a description //the description should be 'Beamtime <Month> <Day> <Year>' //(if beamtime is multiple days, use the 1st day's date) use a pull request to merge main into development this is kinda sloppy, but seems like easiest way to 'reset' things after beamtime","title":"Git Workflow"},{"location":"workflow/#gitgithub-workflow","text":"we should try to generally follow the branching and pull-request workflow described in this SLAC presentation * in our case the two important branches will be main and development * in-between beamtimes, development is used for pushing work * right before beamtimes, development is merged into main * then a branch named beamtime \\ \\ is branched off main * this branch is used for sharing code fixes/changes (pushing-to and pulling-from) during beamtime * after beamtimes, we merge _beamtime \\ \\ back into _main and tag it branching workflow","title":"Git/GitHub Workflow"},{"location":"workflow/#before-beamtime","text":"checkout development (or a earlier stable point of development ) manually run and check the output of script planned for use on the beamtime, as a final sanity check use a pull request to merge development into main to do this follow the instructions in section F) of the doc page Git Commands for Common Tasks main is safeguarded and will require a +1 from another developer make a branch for work during this specific beamtime git checkout -b main beamtime_<month>_<day>_<year> git push origin beamtime_<month>_<day>_<year>","title":"Before Beamtime:"},{"location":"workflow/#during-beamtime","text":"at start of beamtime, everyone needs to download the branch for this beamtime: git fetch git switch beamtime_<month>_<day>_<year> If you need to make changes to the code, first make sure your files are up to date: git pull Now make your changes and upload them: git add -u git commit -m \"<description of changes made>\" git push origin beamtime_<month>_<day>_<year> If someone else made and upload changes, you can download them by doing: git pull","title":"During Beamtime:"},{"location":"workflow/#after-beamtime","text":"make sure all the changes that need to be saved are commited to beamtime \\ \\ _ use a pull request to merge beamtime_ \\ \\ into main add a tag for the beamtime //tag number is arbitrary at this point, just look at last tag and increment one of the values git tag v<tag number> -a //an example tag number would be 1.0.3 //this will open your editor to write a description //the description should be 'Beamtime <Month> <Day> <Year>' //(if beamtime is multiple days, use the 1st day's date) use a pull request to merge main into development this is kinda sloppy, but seems like easiest way to 'reset' things after beamtime","title":"After Beamtime:"}]}