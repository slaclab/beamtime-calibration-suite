{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Beamtime calibration suite This repository contains scripts ran during (or in-between) beamtimes to support calibrating LCLS detectors Some more general info can be found on the team's confluence page: https://confluence.slac.stanford.edu/display/LCLSDET/LCLS+Detector+Department+Home File organization: The following describes what and where things are: /calibrationSuite : The library code lives here, and the functions are able to be imported into other scripts as such: from calibrationSuite.basicSuiteScript import * from calibrationSuite.fitFunctions import * from calibrationSuite.Stats import * from calibrationSuite.cluster import * ... (documentation on the library functionality is still to come, but example usage is seen by scripts in the /suite_scripts folder) /suite_scripts : scripts that use the calibrationSuite library code (these can be called 'high-level scripts') /config_files : files that set values used by the calibrationSuite, which config-file to use is specified by env variable $SUITE_CONFIG /standalone_scripts : scripts that do not use the calibrationSuite library code (also 'high-level scripts') /tests : tests files, can be ran with 'pytest .' from the root project directory or from the tests directory. /data : example data-files used for running the scripts Important branches: development : contains the newest 'good' code, usually has new changes and bug fixes. This is also the default branch for the repo main : stable code that's used during beamtimes. The code from each beamtime (including the changes made during) is tagged","title":"Home"},{"location":"#beamtime-calibration-suite","text":"This repository contains scripts ran during (or in-between) beamtimes to support calibrating LCLS detectors Some more general info can be found on the team's confluence page: https://confluence.slac.stanford.edu/display/LCLSDET/LCLS+Detector+Department+Home","title":"Beamtime calibration suite"},{"location":"#file-organization","text":"The following describes what and where things are: /calibrationSuite : The library code lives here, and the functions are able to be imported into other scripts as such: from calibrationSuite.basicSuiteScript import * from calibrationSuite.fitFunctions import * from calibrationSuite.Stats import * from calibrationSuite.cluster import * ... (documentation on the library functionality is still to come, but example usage is seen by scripts in the /suite_scripts folder) /suite_scripts : scripts that use the calibrationSuite library code (these can be called 'high-level scripts') /config_files : files that set values used by the calibrationSuite, which config-file to use is specified by env variable $SUITE_CONFIG /standalone_scripts : scripts that do not use the calibrationSuite library code (also 'high-level scripts') /tests : tests files, can be ran with 'pytest .' from the root project directory or from the tests directory. /data : example data-files used for running the scripts","title":"File organization:"},{"location":"#important-branches","text":"development : contains the newest 'good' code, usually has new changes and bug fixes. This is also the default branch for the repo main : stable code that's used during beamtimes. The code from each beamtime (including the changes made during) is tagged","title":"Important branches:"},{"location":"commands/","text":"Git Commands for Common Tasks A) Getting the latest changes for use at a beamtime git fetch //if beamtime is across multiple days, use 1st day's date git switch beamtime_<month>_<day>_<year> B) Getting the latest changes from the development branch git checkout development git pull origin development C) Saving a new feature/script/bugfix/etc: make sure you have the latest changes from the remote: git checkout development git pull origin development make a branch for your feature from the development branch: git checkout -b <feature_branch_name> development modify and commit the code, which will probably involve usage of the following commands: git status git add <filename> git commit -m <commit-message> push your feature branch to remote git push origin <feature_branch_name> if want to merge your changes into the development branch * follow F) and make a pull-request from your feature-branch into development D) pulling down someone else's branch (non main/development branch): get updated branch info from remote git fetch origin see list of remote branches to find the correct branch-name git branch -r checkout their branch (use the branch name without the 'origin/' prefix) git checkout <other_persons_branch_name> E) Switching between two branches: the following command lists the local branches you can switch to: git branch then switch between them with: git checkout <branch_want_to_switch_to> F) Making pull request (one branch has been pushed to the remote): go to: https://github.com/slaclab/beamtime-calibration-suite/pulls click green 'New pull request' button in upper right you will see two grey boxes containing branch names and an arrow pointing from one box to the other the \"compare: ...\" box is the branch that will get merged into the \"base: ...\" box's branch the base should be the branch named development once the grey boxes are set correctly, click the green 'Create pull request' button once branch is ready to merge, you can click the ''Merge pull request' button to merge the commit being ready means: potentially reviewed (if big change), passing any automated checks/tests, etc if github is not allowing the merge automatically, you will need to merge or rebase locally and manually handle the conflicts G) Check out tagged commit (old beamtime code will be tagged): same syntax as checking-out a branch, but use the tag name instead: git checkout <tag_name> //ex: git checkout v1.0.0","title":"Useful Git Commands"},{"location":"commands/#git-commands-for-common-tasks","text":"","title":"Git Commands for Common Tasks"},{"location":"commands/#a-getting-the-latest-changes-for-use-at-a-beamtime","text":"git fetch //if beamtime is across multiple days, use 1st day's date git switch beamtime_<month>_<day>_<year>","title":"A) Getting the latest changes for use at a beamtime"},{"location":"commands/#b-getting-the-latest-changes-from-the-development-branch","text":"git checkout development git pull origin development","title":"B) Getting the latest changes from the development branch"},{"location":"commands/#c-saving-a-new-featurescriptbugfixetc","text":"make sure you have the latest changes from the remote: git checkout development git pull origin development make a branch for your feature from the development branch: git checkout -b <feature_branch_name> development modify and commit the code, which will probably involve usage of the following commands: git status git add <filename> git commit -m <commit-message> push your feature branch to remote git push origin <feature_branch_name> if want to merge your changes into the development branch * follow F) and make a pull-request from your feature-branch into development","title":"C) Saving a new feature/script/bugfix/etc:"},{"location":"commands/#d-pulling-down-someone-elses-branch-non-maindevelopment-branch","text":"get updated branch info from remote git fetch origin see list of remote branches to find the correct branch-name git branch -r checkout their branch (use the branch name without the 'origin/' prefix) git checkout <other_persons_branch_name>","title":"D) pulling down someone else's branch (non main/development branch):"},{"location":"commands/#e-switching-between-two-branches","text":"the following command lists the local branches you can switch to: git branch then switch between them with: git checkout <branch_want_to_switch_to>","title":"E) Switching between two branches:"},{"location":"commands/#f-making-pull-request-one-branch-has-been-pushed-to-the-remote","text":"go to: https://github.com/slaclab/beamtime-calibration-suite/pulls click green 'New pull request' button in upper right you will see two grey boxes containing branch names and an arrow pointing from one box to the other the \"compare: ...\" box is the branch that will get merged into the \"base: ...\" box's branch the base should be the branch named development once the grey boxes are set correctly, click the green 'Create pull request' button once branch is ready to merge, you can click the ''Merge pull request' button to merge the commit being ready means: potentially reviewed (if big change), passing any automated checks/tests, etc if github is not allowing the merge automatically, you will need to merge or rebase locally and manually handle the conflicts","title":"F) Making pull request (one branch has been pushed to the remote):"},{"location":"commands/#g-check-out-tagged-commit-old-beamtime-code-will-be-tagged","text":"same syntax as checking-out a branch, but use the tag name instead: git checkout <tag_name> //ex: git checkout v1.0.0","title":"G) Check out tagged commit (old beamtime code will be tagged):"},{"location":"environment/","text":"Setup Environment When running on S3DF, you will first need to setup your environment for python , libraries like psana , etc: source /sdf/group/lcls/ds/ana/sw/conda2/manage/bin/psconda.sh Then you can execute the following to setup some project-specific things (must be ran from beamtime-calibration-suite folder): source setup.sh (must be ran in each new terminal session) This script simplifies setting up the terminal environment and should be all most users will need to do This script does the following: * appends your cloned location of this library to your PYTHONPATH , so scripts in /suite_scripts and other locations on your machine can find the library code * sets the library's output-root to the shared /rix dir used for the current experiment * sets the config file to the currently used rixSuiteConfig.py file The rest of the page has more detail on configuring the scripts. Specifying Output Root The output-root determines where the library will look for an output folder For example, if the root is set to the default value /sdf/data/lcls/ds/rix/rixx1003721/results/scripts/ , the library will look for an output dir ../scan in the location /sdf/data/lcls/ds/rix/rixx1003721/results/scripts/../scan The output-directory can be set using the -p <dir_name> cmdline arg Setting the var to export OUTPUT_ROOT=. will have the library look for an output folder relative to the location of the current script being ran. (. refers to current dir on linux) Point to Config File Specify which config file for the library to use by setting the SUITE_CONFIG environment variable: export SUITE_CONFIG=\"rixSuiteConfig.py\" (relative or full paths should work) You can also set the config-file using the '-cf' or '--configFile' cmd-line arguments (note: if set, the environment variable will always override this cmd-line option) If neither of the above are set, the suite will try to use a default file named suiteConfig.py If no config file can be found and read, the library will fail-out early","title":"Environment"},{"location":"environment/#setup-environment","text":"When running on S3DF, you will first need to setup your environment for python , libraries like psana , etc: source /sdf/group/lcls/ds/ana/sw/conda2/manage/bin/psconda.sh Then you can execute the following to setup some project-specific things (must be ran from beamtime-calibration-suite folder): source setup.sh (must be ran in each new terminal session) This script simplifies setting up the terminal environment and should be all most users will need to do This script does the following: * appends your cloned location of this library to your PYTHONPATH , so scripts in /suite_scripts and other locations on your machine can find the library code * sets the library's output-root to the shared /rix dir used for the current experiment * sets the config file to the currently used rixSuiteConfig.py file The rest of the page has more detail on configuring the scripts.","title":"Setup Environment"},{"location":"environment/#specifying-output-root","text":"The output-root determines where the library will look for an output folder For example, if the root is set to the default value /sdf/data/lcls/ds/rix/rixx1003721/results/scripts/ , the library will look for an output dir ../scan in the location /sdf/data/lcls/ds/rix/rixx1003721/results/scripts/../scan The output-directory can be set using the -p <dir_name> cmdline arg Setting the var to export OUTPUT_ROOT=. will have the library look for an output folder relative to the location of the current script being ran. (. refers to current dir on linux)","title":"Specifying Output Root"},{"location":"environment/#point-to-config-file","text":"Specify which config file for the library to use by setting the SUITE_CONFIG environment variable: export SUITE_CONFIG=\"rixSuiteConfig.py\" (relative or full paths should work) You can also set the config-file using the '-cf' or '--configFile' cmd-line arguments (note: if set, the environment variable will always override this cmd-line option) If neither of the above are set, the suite will try to use a default file named suiteConfig.py If no config file can be found and read, the library will fail-out early","title":"Point to Config File"},{"location":"learning_git/","text":"Learning Git this project uses git as a version control system, along with the GitHub website for hosting the code and multiple other features if you want a good understanding of git, suggest to read the first 3 chapters of https://git-scm.com/book/en/v2 : * the following sections could be skipped: 1.5, 1.6, 2.6, 2.7, 3.5, 3.6 * the book is a recommended resource by the git community but many other tutorials exist, so feel free to use other 'intro to git/github' videos/websites short presentation that summaries the book's content can be found here presentation from SLAC that explains git, github, git workflow, etc can be found here git commands cheat-sheet can be found here (**link will start download of pdf cheat sheet) (if you plan on developing the library) read about GitHub's 'Pull Request' feature here for commit messages, we can try to follow the PyDM guidelines","title":"Learning Git"},{"location":"learning_git/#learning-git","text":"this project uses git as a version control system, along with the GitHub website for hosting the code and multiple other features if you want a good understanding of git, suggest to read the first 3 chapters of https://git-scm.com/book/en/v2 : * the following sections could be skipped: 1.5, 1.6, 2.6, 2.7, 3.5, 3.6 * the book is a recommended resource by the git community but many other tutorials exist, so feel free to use other 'intro to git/github' videos/websites short presentation that summaries the book's content can be found here presentation from SLAC that explains git, github, git workflow, etc can be found here git commands cheat-sheet can be found here (**link will start download of pdf cheat sheet) (if you plan on developing the library) read about GitHub's 'Pull Request' feature here for commit messages, we can try to follow the PyDM guidelines","title":"Learning Git"},{"location":"logging/","text":"Logging Logging calls are added to the library code, and also to some commonly used files in /suite_scripts to act as example Using the following method will append log messages to the log-file if it already exists, or create a new log-file if the file doesn't exist If you want a new log-file for each run of a high-level script, atm you will need to rename the log-file after each run so a new one will be generated To have your high-level script generate logs from the calibrationSuite library code, add the following at the top of the script: import os import calibrationSuite.loggingSetup as ls currFileName = os.path.basename(__file__) ls.setupScriptLogging(\"../logs\" + currFileName[:-3] + \".log\", logging.ERROR) Pass in logging.INFO instead to get alot more output on the state of the program, while also still logging the logging.ERROR messages You can pass any chosen log-file name to the setupScriptLogging function, but using the above will create and write to file named beamtime-calibration-suite/logs/\\<curr script name>.log To add more logging from the high-level script itself (to the same file specified to setupScriptLogging ), you can add the following to the top of the script: import logging logger = logging.getLogger(__name__) Then can add log statements throughout the script with: logger.error(\"Example error msg!\") # for logging when the program goes wrong logger.exception(\"Example exception msg!) # for logging error and also including stack-trace in log logger.info(\"Example info msg!\") # for logging useful info on the state of the program (Note: these must take a statement evaluating to a single string, if 'a', 'b', 'c' are strings you can't do 'logger.info(a,b,c)' but can do 'logger.info(a+b+c)'. And if 'a' is an int, must do 'logger.info(str(a)))","title":"Logging"},{"location":"logging/#logging","text":"Logging calls are added to the library code, and also to some commonly used files in /suite_scripts to act as example Using the following method will append log messages to the log-file if it already exists, or create a new log-file if the file doesn't exist If you want a new log-file for each run of a high-level script, atm you will need to rename the log-file after each run so a new one will be generated To have your high-level script generate logs from the calibrationSuite library code, add the following at the top of the script: import os import calibrationSuite.loggingSetup as ls currFileName = os.path.basename(__file__) ls.setupScriptLogging(\"../logs\" + currFileName[:-3] + \".log\", logging.ERROR) Pass in logging.INFO instead to get alot more output on the state of the program, while also still logging the logging.ERROR messages You can pass any chosen log-file name to the setupScriptLogging function, but using the above will create and write to file named beamtime-calibration-suite/logs/\\<curr script name>.log To add more logging from the high-level script itself (to the same file specified to setupScriptLogging ), you can add the following to the top of the script: import logging logger = logging.getLogger(__name__) Then can add log statements throughout the script with: logger.error(\"Example error msg!\") # for logging when the program goes wrong logger.exception(\"Example exception msg!) # for logging error and also including stack-trace in log logger.info(\"Example info msg!\") # for logging useful info on the state of the program (Note: these must take a statement evaluating to a single string, if 'a', 'b', 'c' are strings you can't do 'logger.info(a,b,c)' but can do 'logger.info(a+b+c)'. And if 'a' is an int, must do 'logger.info(str(a)))","title":"Logging"},{"location":"setup/","text":"Github and Git Setup These steps will get you setup for running and developing the calibration suite! These steps describe the setup for running on the SLAC Shared Scientific Data Facility (S3DF) A S3DF account is needed before following these steps, and info on how to get one is here The only other prerequisites should be a terminal that can run Unix commands (mac and linux have this by default), and basic knowledge of using this terminal 1: Make a github.com account if you already have github account and want to use it, skip to step 2) else to make a new account following the steps here: https://github.com/join your username can be anything, some people like to use the <username>-slac convention (ex: nstelter-slac ) for the email you can use your @slac.stanford.edu address or any other address if you want (just make sure to use the same email in step 5) you will need a code from your email when creating the account 2: Register your github account with \u2018SLAC Lab\u2019 github group first join \u2018#comp-general\u2019 channel on Slack now when viewing this slack channel you should see \u2018Pinned\u2019 and next to it \u2018Workflows\u2019 at top of the page click \u2018Workflows\u2019 -> \u2018SLAC GitHub Access\u2019, and fill out the form with your info wait to receive an email asking you to join the \u2018SLAC Lab\u2019 group, and follow instructions in this email 3: Request write permissions for the repository after completing step 2) , your github account should now be a member of the 'SLAC Lab' github group now go to https://github.com/orgs/slaclab/teams/beamtime_calibration_suite_devs and click the 'Request to join' button towards the upper-right of the page this will grant you write access to the repository (used for development and sharing code-changes during beamtime) 4: Setup your terminal for next steps for the following steps 5) , 6) , 7) , 8) , make sure you terminal is setup first with the following commands: (note: in the 1st command replace <slac-username> with your slac unix account-name) ssh -Yt <slac-username>@s3dflogin.slac.stanford.edu //now enter your info to login to s3df... source /sdf/group/lcls/ds/ana/sw/conda2/manage/bin/psconda.sh all commands entered in the following steps should be done so in this setup terminal (the terminal should now have an active ssh session into S3DF) 5: Config your local git settings Run the following terminal commands: git config --global user.name <github username> git config --global user.email <email used to setup github account> //run one of the following cmds, depending on your preferred editor //(the editor is used during some git operations) git config --global core.editor vim git config --global core.editor emacs 6: Setup SSH Keys for github on s3df first make sure you are logged into your github account in your web browser for the next two bullet-points, make sure you have selected the 'Linux' tab near the top of the page, not 'Mac'! note: the commands on the following pages have to be ran in the terminal setup in step 4) , which is ssh'd into S3DF Follow instructions under \u201cGenerating a new SSH key\u201d and \u201cAdding your SSH key to the ssh-agent\u201d: https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent#generating-a-new-ssh-key Follow instructions under \u201cAdding a new SSH key to your account\u201d: https://docs.github.com/en/authentication/connecting-to-github-with-ssh/adding-a-new-ssh-key-to-your-github-account#adding-a-new-ssh-key-to-your-account To check if this worked, run: ssh -T git@github.com //if SSH is working, you should get the following output: //Hi <github_username>! You've successfully authenticated, but GitHub does not provide shell access. 7: Download the repo run the following terminal commands: cd ~ mkdir repos cd repos git clone git@github.com:slaclab/beamtime-calibration-suite.git //wait for download to finish... cd beamtime-calibration-suite git switch development ls //should see a bunch of folders cd suite_scripts ls //now should see a bunch of python scripts if an error occurs with these commands, SSH setup in step 6) may have had an issue and might need to be debugged 8: Run an example script run the following terminal commands: cd ~/repos/beamtime_calibtation_suite source /sdf/group/lcls/ds/ana/sw/conda2/manage/bin/psconda.sh source setup.sh // must be run in each new terminal session (or added to ~/bashric) cd suite_scripts mkdir setup_test_output //OUTPUT_ROOT=. makes the script to look relative to the current directory for the output-folder OUTPUT_ROOT=. python EventScanParallelSlice.py -r 102 --maxNevents 500 -p /setup_test_outputi //let the script run to completion... ls -lt setup_test_output //if ran correctly, should see these non-empty files: eventNumbers_c0_r102_rixx1005922.npy EventScanParallel_c0_r102__n666.h5 means_c0_r102_rixx1005922.npy 9: Run the tests (optional): run the following terminal commands: cd ~/repos/beamtime_calibtation_suite // setup the test dependencies and test_data submodule source setup_developers.sh pytest .","title":"Setup"},{"location":"setup/#github-and-git-setup","text":"These steps will get you setup for running and developing the calibration suite! These steps describe the setup for running on the SLAC Shared Scientific Data Facility (S3DF) A S3DF account is needed before following these steps, and info on how to get one is here The only other prerequisites should be a terminal that can run Unix commands (mac and linux have this by default), and basic knowledge of using this terminal","title":"Github and Git Setup"},{"location":"setup/#1-make-a-githubcom-account","text":"if you already have github account and want to use it, skip to step 2) else to make a new account following the steps here: https://github.com/join your username can be anything, some people like to use the <username>-slac convention (ex: nstelter-slac ) for the email you can use your @slac.stanford.edu address or any other address if you want (just make sure to use the same email in step 5) you will need a code from your email when creating the account","title":"1: Make a github.com account"},{"location":"setup/#2-register-your-github-account-with-slac-lab-github-group","text":"first join \u2018#comp-general\u2019 channel on Slack now when viewing this slack channel you should see \u2018Pinned\u2019 and next to it \u2018Workflows\u2019 at top of the page click \u2018Workflows\u2019 -> \u2018SLAC GitHub Access\u2019, and fill out the form with your info wait to receive an email asking you to join the \u2018SLAC Lab\u2019 group, and follow instructions in this email","title":"2: Register your github account with \u2018SLAC Lab\u2019 github group"},{"location":"setup/#3-request-write-permissions-for-the-repository","text":"after completing step 2) , your github account should now be a member of the 'SLAC Lab' github group now go to https://github.com/orgs/slaclab/teams/beamtime_calibration_suite_devs and click the 'Request to join' button towards the upper-right of the page this will grant you write access to the repository (used for development and sharing code-changes during beamtime)","title":"3: Request write permissions for the repository"},{"location":"setup/#4-setup-your-terminal-for-next-steps","text":"for the following steps 5) , 6) , 7) , 8) , make sure you terminal is setup first with the following commands: (note: in the 1st command replace <slac-username> with your slac unix account-name) ssh -Yt <slac-username>@s3dflogin.slac.stanford.edu //now enter your info to login to s3df... source /sdf/group/lcls/ds/ana/sw/conda2/manage/bin/psconda.sh all commands entered in the following steps should be done so in this setup terminal (the terminal should now have an active ssh session into S3DF)","title":"4: Setup your terminal for next steps"},{"location":"setup/#5-config-your-local-git-settings","text":"Run the following terminal commands: git config --global user.name <github username> git config --global user.email <email used to setup github account> //run one of the following cmds, depending on your preferred editor //(the editor is used during some git operations) git config --global core.editor vim git config --global core.editor emacs","title":"5: Config your local git settings"},{"location":"setup/#6-setup-ssh-keys-for-github-on-s3df","text":"first make sure you are logged into your github account in your web browser for the next two bullet-points, make sure you have selected the 'Linux' tab near the top of the page, not 'Mac'! note: the commands on the following pages have to be ran in the terminal setup in step 4) , which is ssh'd into S3DF Follow instructions under \u201cGenerating a new SSH key\u201d and \u201cAdding your SSH key to the ssh-agent\u201d: https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent#generating-a-new-ssh-key Follow instructions under \u201cAdding a new SSH key to your account\u201d: https://docs.github.com/en/authentication/connecting-to-github-with-ssh/adding-a-new-ssh-key-to-your-github-account#adding-a-new-ssh-key-to-your-account To check if this worked, run: ssh -T git@github.com //if SSH is working, you should get the following output: //Hi <github_username>! You've successfully authenticated, but GitHub does not provide shell access.","title":"6: Setup SSH Keys for github on s3df"},{"location":"setup/#7-download-the-repo","text":"run the following terminal commands: cd ~ mkdir repos cd repos git clone git@github.com:slaclab/beamtime-calibration-suite.git //wait for download to finish... cd beamtime-calibration-suite git switch development ls //should see a bunch of folders cd suite_scripts ls //now should see a bunch of python scripts if an error occurs with these commands, SSH setup in step 6) may have had an issue and might need to be debugged","title":"7: Download the repo"},{"location":"setup/#8-run-an-example-script","text":"run the following terminal commands: cd ~/repos/beamtime_calibtation_suite source /sdf/group/lcls/ds/ana/sw/conda2/manage/bin/psconda.sh source setup.sh // must be run in each new terminal session (or added to ~/bashric) cd suite_scripts mkdir setup_test_output //OUTPUT_ROOT=. makes the script to look relative to the current directory for the output-folder OUTPUT_ROOT=. python EventScanParallelSlice.py -r 102 --maxNevents 500 -p /setup_test_outputi //let the script run to completion... ls -lt setup_test_output //if ran correctly, should see these non-empty files: eventNumbers_c0_r102_rixx1005922.npy EventScanParallel_c0_r102__n666.h5 means_c0_r102_rixx1005922.npy","title":"8: Run an example script"},{"location":"setup/#9-run-the-tests-optional","text":"run the following terminal commands: cd ~/repos/beamtime_calibtation_suite // setup the test dependencies and test_data submodule source setup_developers.sh pytest .","title":"9: Run the tests (optional):"},{"location":"testing/","text":"Testing Tests are only need to be run by those actively developing the suite, and should especially be run after resolving merge-conflicts, adding in large features, refactoring. Running on S3DF (to use psana library) is required to run the entire suite of the tests, but a subset can still be run without (utilitiy-function tests, etc). This non-psana subset runs automatically on github In short, running the following will check the code: (do so after commiting current changes): // cd to project root source setup_developers.sh // only need to run once ./lint_and_format.sh pytest . Details To setup for running the tests, run the following cmd from the repo root dir: source setup_developers.sh This installs the 'pillow' python dependency (used for diffing .png files), the ruff formatter/linter, and downloads the test_data submodule. (note: only needs to be run once per-repo, unless you manually de-init'd the submodule and want it setup again) (note: this is unlike setup.sh, which needs to be run per-each terminal session (or added to ~/.bashrc)) The code be checked with linting by running: ./lint_and_format.sh This will [lint](https://en.wikipedia.org/wiki/Lint_(software) and attempt to auto-apply fixes, and then format the code. The script may output linting-errors that need to be manually fixed. (note: this will modify your local files, so reccomended to commit changes first -> run script -> commit changes from running script) (note: running 'ruff --line-length 120' will lint the code without auto-fixing) You can run all the tests with the following: pytest . (note: this works from either the project root-dir and also the /tests dir) You can run an individual test-file by specifying the path: pytest tests/test_SuiteScripts.py And run an individual test-case within the test-file by using the '-k' flag: pytest tests/test_SuiteScripts.py -k test_Noise These tests verify that the code in /calibrationSuite and /suite_scripts is currently working as expected. test_SuiteScripts.py runs the files in /suite_script and diffs their real output against expected output in /tests/test_data /tests/test_data stores data from this repo: https://github.com/slaclab/beamtime-calibration-suite-test-data The repo is added as a git submodule , and should be setup by the setup_developers.sh script. Since the test data is large, LFS is used and needs to be installed. (LFS is installed already on S3DF ) Some more info on testing, such as adding now data to the test_data submodule or add a new test-case to_suite_scripts_ tests, can be found in this file.","title":"Testing"},{"location":"testing/#testing","text":"Tests are only need to be run by those actively developing the suite, and should especially be run after resolving merge-conflicts, adding in large features, refactoring. Running on S3DF (to use psana library) is required to run the entire suite of the tests, but a subset can still be run without (utilitiy-function tests, etc). This non-psana subset runs automatically on github In short, running the following will check the code: (do so after commiting current changes): // cd to project root source setup_developers.sh // only need to run once ./lint_and_format.sh pytest .","title":"Testing"},{"location":"testing/#details","text":"To setup for running the tests, run the following cmd from the repo root dir: source setup_developers.sh This installs the 'pillow' python dependency (used for diffing .png files), the ruff formatter/linter, and downloads the test_data submodule. (note: only needs to be run once per-repo, unless you manually de-init'd the submodule and want it setup again) (note: this is unlike setup.sh, which needs to be run per-each terminal session (or added to ~/.bashrc)) The code be checked with linting by running: ./lint_and_format.sh This will [lint](https://en.wikipedia.org/wiki/Lint_(software) and attempt to auto-apply fixes, and then format the code. The script may output linting-errors that need to be manually fixed. (note: this will modify your local files, so reccomended to commit changes first -> run script -> commit changes from running script) (note: running 'ruff --line-length 120' will lint the code without auto-fixing) You can run all the tests with the following: pytest . (note: this works from either the project root-dir and also the /tests dir) You can run an individual test-file by specifying the path: pytest tests/test_SuiteScripts.py And run an individual test-case within the test-file by using the '-k' flag: pytest tests/test_SuiteScripts.py -k test_Noise These tests verify that the code in /calibrationSuite and /suite_scripts is currently working as expected. test_SuiteScripts.py runs the files in /suite_script and diffs their real output against expected output in /tests/test_data /tests/test_data stores data from this repo: https://github.com/slaclab/beamtime-calibration-suite-test-data The repo is added as a git submodule , and should be setup by the setup_developers.sh script. Since the test data is large, LFS is used and needs to be installed. (LFS is installed already on S3DF ) Some more info on testing, such as adding now data to the test_data submodule or add a new test-case to_suite_scripts_ tests, can be found in this file.","title":"Details"},{"location":"usage/","text":"Script Usage Currently, script usage is documented across a few confluence pages (TODO: document this better and in one place) General Info: https://confluence.slac.stanford.edu/display/LCLSDET/Feb+2024+beamtime+analysis+instructions Also: https://confluence.slac.stanford.edu/display/LCLSDET/Current+%28Feb+2024%29+single+photon+analysis https://confluence.slac.stanford.edu/display/LCLSDET/Running+analysis+and+plotting+results+in+psana2+parallel+scripts https://confluence.slac.stanford.edu/display/LCLSDET/Procedure+for+cluster-based+gain+analysis+while+the+calib+db+is+down+or+pedestals+are+bad","title":"Script Usage"},{"location":"usage/#script-usage","text":"Currently, script usage is documented across a few confluence pages (TODO: document this better and in one place) General Info: https://confluence.slac.stanford.edu/display/LCLSDET/Feb+2024+beamtime+analysis+instructions Also: https://confluence.slac.stanford.edu/display/LCLSDET/Current+%28Feb+2024%29+single+photon+analysis https://confluence.slac.stanford.edu/display/LCLSDET/Running+analysis+and+plotting+results+in+psana2+parallel+scripts https://confluence.slac.stanford.edu/display/LCLSDET/Procedure+for+cluster-based+gain+analysis+while+the+calib+db+is+down+or+pedestals+are+bad","title":"Script Usage"},{"location":"workflow/","text":"Git/GitHub Workflow We should try to generally follow the branching and pull-request workflow described in this SLAC presentation * in our case the two important branches will be main and development * in-between beamtimes, development is used for pushing work * right before beamtimes, development is merged into main * then a branch named beamtime_<month>_<day>_<year>_ is branched off main * this branch is used for sharing code fixes/changes (pushing-to and pulling-from) during beamtime * after beamtimes, we merge beamtime_<month>_<day>_<year> back into main and tag it Before Beamtime: checkout development (or a earlier stable point of development ) use a pull request to merge development into main to do this follow the instructions in section F) of the doc page Git Commands for Common Tasks main is safeguarded and will require a +1 from another developer make a branch for work during this specific beamtime git checkout -b main beamtime_<month>_<day>_<year> git push origin beamtime_<month>_<day>_<year> Now run the tests with the following cmd: (assuming the tests have been setup already with setup_developers.sh) pytest . Then see that all tests are passing (unless there are any expected failures) If any new test-less scripts are planned to be used (or have too many expected test-failures), manually run any scripts we plan to use to verify they still work During Beamtime: at start of beamtime, everyone needs to download the branch for this beamtime: git fetch git switch beamtime_<month>_<day>_<year> If you need to make changes to the code, first make sure your files are up to date: git pull Now make your changes and upload them: git add -u git commit -m \"<description of changes made>\" git push origin beamtime_<month>_<day>_<year> If someone else made and upload changes, you can download them by doing: git pull After Beamtime: make sure all the changes that need to be saved are commited to beamtime_<month>_<day>_<year> use a pull request to merge beamtime_<month>_<day>_<year> into main add a tag for the beamtime //tag number is arbitrary at this point, just look at last tag and increment one of the values git tag v<tag number> -a //an example tag number would be 1.0.3 //this will open your editor to write a description //the description should be 'Beamtime <Month> <Day> <Year>' //(if beamtime is multiple days, use the 1st day's date) use a pull request to merge main into development this is kinda sloppy, but seems like easiest way to 'reset' things after beamtime","title":"Git Workflow"},{"location":"workflow/#gitgithub-workflow","text":"We should try to generally follow the branching and pull-request workflow described in this SLAC presentation * in our case the two important branches will be main and development * in-between beamtimes, development is used for pushing work * right before beamtimes, development is merged into main * then a branch named beamtime_<month>_<day>_<year>_ is branched off main * this branch is used for sharing code fixes/changes (pushing-to and pulling-from) during beamtime * after beamtimes, we merge beamtime_<month>_<day>_<year> back into main and tag it","title":"Git/GitHub Workflow"},{"location":"workflow/#before-beamtime","text":"checkout development (or a earlier stable point of development ) use a pull request to merge development into main to do this follow the instructions in section F) of the doc page Git Commands for Common Tasks main is safeguarded and will require a +1 from another developer make a branch for work during this specific beamtime git checkout -b main beamtime_<month>_<day>_<year> git push origin beamtime_<month>_<day>_<year> Now run the tests with the following cmd: (assuming the tests have been setup already with setup_developers.sh) pytest . Then see that all tests are passing (unless there are any expected failures) If any new test-less scripts are planned to be used (or have too many expected test-failures), manually run any scripts we plan to use to verify they still work","title":"Before Beamtime:"},{"location":"workflow/#during-beamtime","text":"at start of beamtime, everyone needs to download the branch for this beamtime: git fetch git switch beamtime_<month>_<day>_<year> If you need to make changes to the code, first make sure your files are up to date: git pull Now make your changes and upload them: git add -u git commit -m \"<description of changes made>\" git push origin beamtime_<month>_<day>_<year> If someone else made and upload changes, you can download them by doing: git pull","title":"During Beamtime:"},{"location":"workflow/#after-beamtime","text":"make sure all the changes that need to be saved are commited to beamtime_<month>_<day>_<year> use a pull request to merge beamtime_<month>_<day>_<year> into main add a tag for the beamtime //tag number is arbitrary at this point, just look at last tag and increment one of the values git tag v<tag number> -a //an example tag number would be 1.0.3 //this will open your editor to write a description //the description should be 'Beamtime <Month> <Day> <Year>' //(if beamtime is multiple days, use the 1st day's date) use a pull request to merge main into development this is kinda sloppy, but seems like easiest way to 'reset' things after beamtime","title":"After Beamtime:"}]}